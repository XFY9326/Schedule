---
title: '课程解析工具方法'
---

## 概述

此处将会介绍通用工具方法的使用方法  
可以根据情况添加函数  

**注：建议在适配前查看该工具库，合理的使用可以提高适配效率**

## CourseAdapterTools

存放Kotlin Extension等顶层函数，一般不建议修改

``` kotlin
// 重新整理周数数组，减少不必要的尾部信息
fun BooleanArray.arrangeWeekNum(): BooleanArray

// 是否有课程
// num：节次（从1开始）
fun BooleanArray.hasCourse(num: Int): Boolean

// 整形Collection转BooleanArray
// 1 -> Index 0
// 2 -> Index 1
fun Collection<Int>.toBooleanArray(): BooleanArray

// Jsoup选择单个元素，若不存在则报错
// cssQuery：CSS查询语句
fun Element.selectSingle(cssQuery: String): Element

// 带有响应错误处理的HttpClient
// Ktor默认会抛出网络请求状态码错误，因此可能需要特殊处理
// action 网络请求
// handleError 处理错误
suspend fun <T> HttpClient.runResponseCatching(
    action: suspend HttpClient.() -> T,
    handleError: suspend ResponseException.() -> T,
): T
```

## CourseAdapterUtils

存放静态函数  

``` kotlin
// 构建简单的Http客户端
// supportJson：是否支持JSON（Ktor对Kotlin serialization的支持）
// hasRedirect：是否允许重定向
// 返回：HttpClient
fun buildSimpleHttpClient(supportJson: Boolean = false, hasRedirect: Boolean = true): HttpClient

// 创建日期格式解析
// format：日期格式
// 返回：SimpleDateFormat
fun newDateFormat(format: String = "yyyy-MM-dd"): SimpleDateFormat

// 简单的学期时间修复
// 适用于学期时间有可能只有开头的情况
// termStart：学期开始时间
// termEnd：学期结束时间
// 返回：Pair<学期开始时间, 学期结束时间>
fun simpleTermFix(termStart: Date?, termEnd: Date?): Pair<Date, Date>?

// 整数数字间隔解析
// 输入示例：5  1,2-3,4
// str：需要解析的字符串
// groupDivider：组分割符号
// durationDivider：时间段分割符号
// oddOnly：仅限偶数
// evenOnly：仅限奇数
// 返回：整形集合
fun parseNumberPeriods(str: String, groupDivider: String = ",", durationDivider: String = "-", oddOnly: Boolean = false, evenOnly: Boolean = false): Set<Int>

// 整数数字列表解析
// 输入示例：1,2,4,5
// str：字符串
// divider：分隔符
// 返回：整形列表
fun parseNumberList(str: String, divider: String = ","): List<Int>

// 用于周数解析
// 用法同parseNumberPeriods
// 返回：BooleanArray
fun parseWeekNum(str: String, groupDivider: String = ",", durationDivider: String = "-", oddOnly: Boolean = false, evenOnly: Boolean = false): BooleanArray

// 将整形Collection转为时间间隔数组
// arr：整形Collection
// 返回：时间间隔数组
// 时间间隔（闭区间） TimePeriod：start，end，length
fun parseIntCollectionPeriod(arr: Collection<Int>): List<TimePeriod>

// 解析多个课程时间
// 用于上课时间并非完整的时间片段（例如：1-3）而是只包含节次（例如：1，2，3，5）的课程
// weeks：周数
// weekDay：星期
// numArr：上课时间
// location：地点
// 返回：课程时间列表
fun parseMultiCourseTimes(weeks: BooleanArray, weekDay: WeekDay, numArr: Collection<Int>, location: String? = null): List<CourseTime>

// 解析中文的星期
// str：中文数字字符串
// 返回：星期 WeekDay
fun parseWeekDayChinese(str: String): WeekDay

// 解析中文单双周
// str：中文'单'或'双'或'单周'或'双周'
// 返回：Pair<是否是单周, 是否是双周>
fun parseWeekModeChinese(str: String?): Pair<Boolean, Boolean>
```

## CourseParseResult

用于课程解析结果生成，提供错误捕捉，异常处理以及课程添加合并等功能  

``` kotlin

// 构造CourseParseResult
// 参数：预期的课程数量（填写可提高性能）
CourseParseResult.Builder(exceptCourseAmount: Int? = null)

// Builder中的方法

// 类的主要目的：
// 在action函数中运行的操作将会自动处理解析报错的情况
// 若抛出非CourseAdapterException错误或严格模式下有效的错误，将会认定是可以忽略的错误，保存错误后继续解析可解析课程；反之则停止解析直接报错
// 使用该函数主要目的是为了解析课程时，解决部分页面会出现少数课程信息错误的问题。若在设置中启用允许不完整的课表功能，将可以导入部分解析成功的课程。

// 新增课程
// 参数：是否跳过解析报错的课程，课程解析函数（返回null表示跳过该课程不添加）
// 注：此处跳过的错误仅指非CourseAdapterException错误或严格模式下有效的错误，即可忽略的错误
fun add(skipUnknownErrorCourse: Boolean = true, action: () -> Course?)

// 在包含报错处理的情况下运行代码
// 参数：是否跳过解析报错的课程，执行的函数
// 返回：是否未出现任何错误
// 注：此处跳过的错误仅指非CourseAdapterException错误或严格模式下有效的错误，即可忽略的错误
fun withCatcher(skipUnknownError: Boolean = true, action: () -> Unit): Boolean

// 直接添加课程
// 参数：课程
// 返回：是否未出现任何错误
fun add(course: Course): Boolean

// 生成CourseParseResult
// 参数：是否需要合并相同的课程，是否需要合并相同的课程时间
// ‘合并相同的课程’开启后，将会根据[课程]与[教师]合并相同的课程，课程时间将会去重合并
// ‘合并相同的课程时间’开启后，将会对同一个课程下的课程时间中的上课时间进行合并
fun build(combineCourse: Boolean = false, combineCourseTime: Boolean = false): CourseParseResult
```

相关：  
[课程导入严格模式]({{< ref "注意事项#课程导入严格模式" >}})  
[课程相关的数据结构]({{< ref "课程相关的数据结构" >}})  
[错误处理]({{< ref "错误处理" >}})

### 错误捕捉机制详解

以下情况仅在启用‘跳过未知错误’功能的参数时有效（默认开启）：  
如果抛出非CourseAdapterException错误，则判定为意外错误（可忽略错误），记录错误，继续运行  
如果抛出仅限严格模式有效的CourseAdapterException错误，则判定为可忽略错误，记录错误，继续运行  
如果抛出其他CourseAdapterException错误，则判定为已知错误，记录错误，停止运行  

-----

注：多数情况下<新增课程>方法可以解决问题，但是对于有些代码不能在lambda函数运行或者解析的顺序不同的情况，需要<在包含报错处理的情况下运行代码>与<直接添加课程>方法共同使用实现效果。实际使用时，就算代码中不使用<在包含报错处理的情况下运行代码>的方法，解析框架也会捕捉错误，但是就没有‘跳过部分解析错误的课程’这个功能了，应此建议使用该类提供的方法而不是直接使用<直接添加课程>方法。
